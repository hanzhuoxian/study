## 语言精要

### rust 语言的基本构成

#### 语言规范


Rust 语言规范主要由 [Rust 语言参考](https://doc.rust-lang.org/reference/index.html)（[github rust 语言参考](https://github.com/rust-lang/reference/)）和 RFC 文档共同构成。

Rust 语言参考是官方维护的一份参考文档包含：

- 对每种语言结构及其用法的描述
- 对内存模型、并发模型、链接、调试等内存的描述
- 影响语言设计的基本原理和参考

RFC 文档

Rust 引入了规范化的 RFC 流程，RFC 文档是涵盖了语言特性的设计意图、详细设计、优缺点的完整技术方案。
社区中每个人都可以提 RFC 经过社区讨论、核心团队评审通过之后才能进入具体实现阶段。

[Rust RFC 文档](https://rust-lang.github.io/rfcs/introduction.html)

#### 编译器

`Rust` 是一门静态编译型语言。`Rust` 官方的编译器叫 `rustc`，负责将 rust 源代码编译为可执行文件或其他库文件（.a .so .lib .ddl等）。

rustc 的特点：
1. 跨平台
2. 交叉编译
3. 使用 llvm 作为编译器后端
4. rustc 是 rust 语言开发的包含在 rust 语言源码中
5. rustc 对 Rust 源码进行词法语法分析、静态类型检查，最终将代码翻译为 LLVM IR
6. rustc 输出的错误非常友好

#### 核心库

Rust 语言的语法由核心库和标准库共同提供。其中 Rust 核心库是标准库的基础。核心库中定义的是 Rust 语言的核心，
不依赖于操作系统和和网络等相关库，甚至不知道堆分配也不提供并发和 I/O。

可以在模块顶部引入 `#![no_std]` 来使用核心库，核心库和标准库功能有有些重复，做嵌入式应用开发核心库是必须的。

- 基础的 trait，如 Copy、Debug、Display、Option等
- 基本原始类型 如：bool、 char、i8/u8、i16/u16、i32/u32、i64/u64、isize/usize、f32/f64、str、array、slice、tuple、pointer等
- 常用功能型数据类型 如：String、Vec、HashMap、Rc、Arc、Box等。
- 常用宏定义如： println!、assert!、panic!、vec!等

#### 标准库

Rust 标准库提供应用程序开发所需要的基础和跨平台支持。标准库包含的内容大概如下：

- 与核心库一样的基本 trait 、原始数据类型、功能型数据类型和常用宏，以及与核心库几乎完全一致的 API。
- 并发、I/O和运行时。例如提供线程模块、用于消息传递的通道类型、Sync trait 等并发模块、文件、TCP、UDP、管道、套接字等常见 I/O。
- 平台抽象。os 模块提供了许多与操作系统交互的基本功能，包括程序参数、环境变量和目录导航、路径模块封装了处理文件路径的平台特定规则。
- 底层操作接口，比如：std::mem std::ptr std::intrinsics等，操作内存、指针、调用编译器固有函数。
- 可选和错误处理类型 Option 和 Result、以及各种迭代器等。

#### 包管理器

把按一定规则组织的多个 rs 文件编译后就得到一个包（crate）。包是 Rust 代码的基本编译单元，也是程序员之间共享代码的基本单元。
Rust 社区公开的第三方包都集中在 crates.io 网站上面。他们的文档被自动发布到 docs.rs 上。

Rust 提供了非常方便的包管理器 Cargo。它不仅局限于包管理，它还为 Rust 提供了标准的工作流。Cargo 能够管理整个工作流程，从创建项目、
运行单元测试和基准测试、到构建发布链接库、再到运行可执行文件，等等。

### 语句表达式

Rust 中的语法可以分为两大类：语句（Statement） 和表达式（Expression）。语句是指要执行的一些操作和产生副作用的表达式。
表达式主要用于计算求值。

语句又分为两种： 声明语句 （Declaration Statement）和表达式语句（Expression Statement）。

- 声明语句用于声明各种语言项（Item），包括声明变量、静态变量、常量、结构体、函数等，以及通过 extern 和 use 关键字引入包和模块。
- 表达式语句，特指以分号结尾的表达式。此类表达式求值结果会被舍弃，并总是返回单元类型()。

```rust
//  extern crate std;  // 声明语句 Rust 自动引入
// use std::prelude::v1::*; // 声明语句 Rust 自动引入

fn main() {
    pub fn answer() -> () {
        let a = 40;
        let b = 2;
        assert_eq!(sum(a, b), 43)
    }

    pub fn sum(a: i32, b: i32) -> i32 {
        a + b
    }
    answer();

    fn temp() -> i32 {
        1
    }

    let x = temp();
    // temp() = &x
}

```

`answer` 返回值类型为单元类型()。单元类型拥有唯一的值就是他本身，为了描述方便，将该值称为单元值。

Rust 在编译器解析代码的时候，如果碰到分号就回继续往后面执行；如果碰到语句则执行语句；如果碰到表达式则对表达式进行求值，如果分号后面
什么都没有那么就回在后面补上单元值()。

当遇到函数的时候，会将函数体的花括号识别为块表达式（Block Expression）。块表达式是由一对花括号和一系列表达式组成，它总是返回块中
最后一个表达式的值。

从这个角度看可以将 Rust 看作一切皆表达，由于分号后面什么都没有时自动补单元值()的特点，我们可以将 Rust 中的语句看作计算结果均为
单元值 () 的特殊表达式。对于正常的表达式来说会得到正常的求值结果。

### 变量与绑定

通过 `let` 关键字来创建变量，这是 Rust 从函数式编程语言中借鉴的语法形式。`let` 创建的变量一般称为绑定（Binding）。
它表明了标识符（Identifier）和值（Value）之间建立的一种关联关系。

#### 位置表达式和值表达式

Rust 中的表达式一般可以分为 位置表达式（Place Expression） 和值表达式（Value Expression）。在其他语言中一般叫做左指和右值。

位置表达式就是表示内容位置的表达式，分别有以下几类：
- 本地变量
- 静态变量
- 解引用 (*expr)
- 数组索引(expr[expr])
- 字段引用（expr.field）
- 位置表达式组合

通过位置表达式可以对某个数据单元的内存进行读写。主要是写操作，这也是位置表达式可以被赋值的原因。

除此之外的表达式就是值表达式。值表达式只引用了某个存储单元地址中的数据。它相当于数据值，只能进行读操作。
从语义角度来讲，位置表达式代表了持久性数据，值表达式代表了临时数据。位置表达式一般有持久的状态。值表达式要么是字面量，
要么是表达式求值过程中创建的临时值。

表达式的求值过程在不同的上下文中会有不同的结果。求值上下文也分为位置上下文 （Place Context）和值上下文（Value Context）。
下面几种表达式属于位置上下文：

- 赋值或者复合赋值语句左侧的操作数
- 一元引用表达式的独立操作数
- 包含隐式借用（引用）的操作数
- match 判别式或 let 绑定右侧在使用 ref 模式匹配的时候

除了上述几种情况其余情况都属于值上下文。值表达式不能出现在位置上下文中。

#### 不可变绑定与可变绑定

使用 `let` 关键字声明的位置表达式默认不可变，为不可变绑定

```rust
let a = 1; // 不可变绑定
// a = 2; //cannot assign twice to immutable variable

let mut b = 2; // 可变绑定
b = 3;
```

#### 所有权与引用

当位置表达式出现在值上下文中时，该位置表达式会把内存地址转移给另外一个位置表达式，这其实是所有权的转移。

在语义上，**每个变量绑定实际上都拥有该存储单元的所有权，这种转移内存地址的行为就是所有权（ownership）的转移，在 Rust 中被称为
移动 （Move）语义，那种不转移的情况实际上是一种复制（Copy）语义。** Rust 没有 GC，所以完全依赖所有权来进行内存管理。

在日常开发中，有时候并不需要转移所有权。Rust 提供引用操作符（&），可直接获取表达式的存储单元地址，即内存位置。可以通过该内存位置对内存进行读取。引用之后被引用的变量仍然保留他们的所有权，引用者只是对
被引用者所有权的借用。所以引用也被称为借用。

### 函数与闭包

#### 函数定义

定义函数使用 fn 关键字，下面是一个函数示例。

```rust
pub fn fizz_buzz(num :i32) -> String {
    if num % 15 == 0 {
        return "fizzbuzz".to_string();
    } else if num % 3 == 0 {
        return "fizz".to_string();
    } else if num % 5 == 0  {
        return "buzz".to_string();
    } else {
        return num.to_string();
    }
}
```

#### 作用域与声明周期

Rust 语言的作用域是静态作用域，即词法作用域（Lexical Scope）。由一对花括号来开辟作用域，其作用域在
词法分析阶段就已经确定了，不会动态改变。

连续使用 `let` 定义同名变量的做法叫做变量遮蔽（Variable Shadow）。但是最终的变量 v 是由第二个变量定义所决定。

```Rust
fn main() {
    let v = "hello world!";
    assert_eq!(v, "hello world!");

    let v = "hello Rust!";
    assert_eq!(v, "hello Rust!");

    { // 词法作用域块 1
        let v = "hello World!";
        assert_eq!(v, "hello World!"); 
    }

    // 证明 词法作用域块 1 与 main 作用域相互独立
    assert_eq!(v, "hello Rust!"); 
}

```

在不同词法作用域内声明的变量绑定，拥有不同的声明周期（Life Time）。尽管如此，变量绑定的声明周期总是
遵循这样的规律：从使用 `let` 声明创建变量绑定开始，到超出词法作用域的范围时结束。

#### 函数指针

在 Rust 中，函数为一等公民，这意味着函数自身就可以作为函数的参数和返回值使用。

```Rust

fn main() {
    let a = 2;
    let b = 3;
    assert_eq!(math(sum, a, b), 5);
    assert_eq!(math(product, a, b), 6);
}

pub fn math(op: fn(i32, i32) -> i32, a: i32, b: i32) -> i32 {
    op(a, b)
}

fn sum(a:i32, b:i32) -> i32 {
    a + b
}

fn product(a:i32, b:i32) -> i32 {
    a * b
}

```

在函数 `math` 中，其函数签名的第一个参数为 `fn(i32, i32) -> i32` 类型 。这在 Rust 中
是函数指针（fn pointer）类型，直接使用函数名称来作为函数指针。

#### CTFE 机制

Rust 语言也可以像 C++ 或者 D 语言那样，拥有编译时执行函数的能力（Compile-Time Function Execution， CTFE） 的能力。


```rust
// #![feature(const_fn)]
const fn init_len() -> usize {
    return 5;
}
fn main() {
    let arr = [0; init_len()];
    println!("{} , {}", arr[0] , arr.len())
}

```

使用 const fn 来定义函数 `init_len` ，该函数返回一个固定值 5，并且在 `main` 中通过 [0; N] 这种形式来初始化初始值为0 长度为 N 的数组。其中 N 是由函数 `init_len` 求得的。

Rust 中固定长度的数组必须在编译期间就知道长度，否则就会出现编译报错。

Rust 中的 CTFE 是由 miri 来执行的。miri 是一个 MIR 解释器，目前已经被集成到了 Rust 的编译器 rustc 中。Rust 目前可以支持的常量表达式有：字面量、元组、数组、字段结构体、枚举、只包含单行代码的块表达式、范围等。

#### 闭包

闭包也叫匿名函数。闭包有以下几个特点：

- 可以像函数一样被调用。
- 可以捕获上下文环境中的自由变量。
- 可以自动推断输入和返回的类型。

闭包和函数的重要区别，闭包可以捕获外部变量，函数不可以。

```rust
fn main() {

    let out = 42;

    fn add(i: i32, j: i32) -> i32 {
        i + j
    }

    let closure_annotated = |i: i32, j: i32| -> i32 { i + j + out };

    let closure_inferred = |i, j| i + j + out;

    let i = 1;
    let j = 2;
    
    assert_eq!(3, add(i, j));
    assert_eq!(45, closure_annotated(i, j));
    assert_eq!(45, closure_inferred(i, j));
}

```

闭包作为参数

```rust
//  无参闭包
fn closure_math<F: Fn() -> i32>(op: F) -> i32 {
    op()
}

// 有参闭包
fn closure_math_args<F: Fn(i32, i32) -> i32>(op: F, a: i32, b: i32) -> i32 {
    op(a, b)
}

fn main() {
    let a = 2;
    let b = 3;

    assert_eq!(closure_math(|| a + b), 5);
    assert_eq!(closure_math(|| a * b), 6);

    assert_eq!(
        closure_math_args(|c: i32, d: i32| -> i32 { a + b + c + d }, 2, 3),
        10
    )
}

```

闭包作为返回值

```rust
fn two_times_impl() -> impl Fn(i32) -> i32 {
    let i = 2;
    move |j|j*i
}

fn main() {
    let result = two_times_impl();
    assert_eq!(result(2), 4);
}

```

使用 `impl Fn(i32) -> i32` 作为返回值，它表示实现了 `Fn(i32) -> i32` 的类型。在函数定义时并不知道具体的返回类型，但是在函数调用时编译器会推断出来。这个过程也是 0 成本抽象的一切都发生在编译期间。

最后返回时使用了 `move` 关键字。这是因为在一般情况下，闭包默认会按引用捕获变量。如果将此闭包返回那么引用也会跟着返回。但是在整个函数调用之后，函数内的本地变量 `i` 就会被销毁。

### 流程控制表达式

#### 条件表达式

表达式一定会有值，所以 `if` 表达式的值必须返回一个类型的值才可以。这也是 Rust 没有三元操作符的原因，`if` 表达式的求值规则和块表达式一致。

```rust
fn main() {
    let n = 13;
    let big_n = if n < 10 && n > -10 { 10 * n } else { n / 2 };
    assert_eq!(big_n, 6)
}

```

`big_n` 绑定的值是由一个 if 表达式来完成的。通过计算 n 的区间大小，来决定最终的值。编译器根据 if 块中的值确定表达式的类型是 i32，在 else 块中会对结果进行截取。

#### 循环表达式

Rust 包括三种循环表达式: `while`、 `loop` 、 `for...in ` ，其用法和其他编程语言相应的表达式基本类似。

用 `for...in `  实现 fizzbuzz 程序，`for...in ` 本质上是一个迭代器，其中是一个 1..101 类型，它是一个迭代器。`for` 的每一次循环都从迭代器中取值，当迭代器中没有值的时候，`for` 循环结束。

```rust
fn main() {
    for n in 1..101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
    }
}

```

`while true` 循环示例，其中 `while` 循环条件使用了硬编码的 `true` ，目的是实现无限循环。这种看似非常正确的代码会引起 Rust 编译器报错。

错误提示称 `while true` 循环 返回的是单元值，而函数 `while_true` 返回的是 `i32`。但是 `while true` 循环中使用了关键字 `return`，应该返回 `i32` 才对，为什么会报错呢？这是因为 Rust 编译器在对 `while` 循环做流分析（Flow Sensitive）的时候，不会检查循环条件，编译器会认为 `while` 循环的条件可真可假，所以循环体里的表达式也会被忽略，此时编译器只知道 `while` 循环返回的是单元值，而函数返回的是 `i32`。这一切都是 CTFE 功能的限制，`while` 条件表达式无法作为编译器常量来使用，只有等 CTFE 功能完善后才能使用。


```rust

fn while_true(x :i32) -> i32 {
    while true {
        return x + 1;
    }
}
fn main() {
    let y = while_true(5);
    assert_eq!(y, 6);
}

```

#### match 表达式与模式匹配

在 Rust 中 match 分支使用了模式匹配（Pattern Matching）技术。模式匹配在数据结构字符串中经常出现，比如在某个字符串中找出与该子串相同的所有子串。在编程语言中，模式匹配用于判断类型或值是否存在可以匹配的模式。模式匹配在很多函数式编程语言中已被广泛使用。

在 Rust 中，match 左边就是模式，右边就是执行代码。模式匹配同时也是一个表达式，与 if 表达式类似，所有分支必须返回同一类型。但是左侧的模式可以是不同的。可以是单个值、范围、多个值、通配符，值得注意的是使用 @ 可以将模式中的值绑定给一个变量，供分支右侧的代码使用。这类匹配叫绑定模式（Binding Mode）。match 表达式必须穷尽每一种可能，所以一般情况下都会使用_通配符来处理剩余情况。

```rust
fn main() {
    let number = 42;
    match number {
        0 => {println!("Origin")},
        1..3 => {println!("All")},
        5 | 7 | 13 => {println!("Bad Luck")}
        n @ 42 => {println!("Answer is {}", n)},
        _ => println!("Common")
    }
}

```