## 内存管理

手动内存管理：需要开发者手动使用 `malloc` 和 `free` 显式管理内存
自动内存管理：语言通过Gc等手段自动管理内存

### 通用概念

现代操作系统在保护模式下一般都采用虚拟内存管理技术。

虚拟地址空间：是线性空间，用户所接触到的地址都是虚拟地址，而不是真实的物理地址。利用这种虚拟地址不但能保护操作系统，
让进程在各自的地址空间中操作内存，更重要的是用户可以使用比物理内存更大的地址空间。虚拟地址空间被认为的分为两部分用户空间和内核空间。他们的比例是 3:1 （linux）。

#### 栈

栈（stack）：栈是内存中一块连续的区域，栈的内存地址是向下增长的，栈顶指针指向栈顶。操作栈的一段被称为栈顶，另一端被称为栈底。

物理内存本身并不区分堆和栈，但是虚拟内存空间中需要分出一部分内存，用于支持 CPU 入栈和出栈的指令。这部分内存空间就是栈内存。

栈顶由栈指针寄存器 ESP 保存，起初栈顶指向栈底位置，当有数据入栈时，栈顶地址像下增长，地址由高地址编程低地址。当有数据被弹出时，栈顶地址向上增长，地址由低地址编程高地址。

栈内存最重要的作用在程序运行过程中保存函数调用所需维护的信息。存储每次函数调用所需信息的记录单元被称为栈帧（stack frame）。有时也被称为活动记录。

栈帧一般包含三方面内容：
1. 函数参数和返回地址
2. 函数局部变量、临时变量
3. 保存的上下文

EBP 是帧指针（Frame Pointer），指向当前栈帧的一个固定位置，而 ESP 是栈指针（Stack Pointer），始终指向栈顶。
EBP 指向的值是调用该函数之前的旧 EBP 值，这样在返回时就可以通过该值恢复到调用前的值。由 EBP 和 ESP 指针构成的一个区域就是一个栈帧。一般指当前栈帧。

栈的分配非常快，其中的局部变量都是预分配内存，在栈上分配的都是固定大小的内存。当函数结束调用的时候，栈帧会自动销毁，局部变量也会自动释放。所以栈帧上数据的声明周期都是一个函数调用周期内的。




#### 堆

堆（heap）内存，相对长久的保存内存中的数据。堆内存是一块巨大的内存空间，占了虚拟内存空间的绝大部分，程序不可以主动申请栈内存，但是可以主动申请堆内存。在堆内存中存储的数据会在内存中一直存在除非主动释放。

堆是一大块内存空间，程序通过 malloc 申请到的内存是大小不一的，不连续且无序的，所以如何管理堆内存是一个问题，这就涉及到堆分配算法，堆分配的算法有很多种，可以分为两大类 空闲链表（Free List） 和 位图标记（Bitmap）。

空闲链表就是把堆中空闲的内存地址记录为链表，当系统收到程序申请时，会遍历该列表，当找到适合的空间堆节点，会将此节点从列表中删除。当空间被回收以后在加入到空闲链表中。

位图的核心思想是，将整个堆划分为大量大小相等的块。当程序申请内存时，总是分配整数个块的空间，每块内存都用一个二进制位来标识其其状态，如果被占用，则相应位图中的位置被置为 1，如果该内存块空闲，则响应的位图中的位置被置为 0。位图的优势是速度快。缺点是容易产生内存碎片。

Rust 默认自带两个分配器 alloc_system 和 alloc_jemalloc

jemalloc 优势：
分配或回收内存更快
碎片更少
对内核友好
良好的可伸缩性


#### 内存布局

内存中数据的排列方式称为内存布局。不同的排列方式占用的内存不同。也会间接影响 CPU 内存访问效率。为了权衡空间占用和访问效率，引入了内存对齐规则。

CPU 在单位时间能处理的一组二进制数称为字。这组二进制数的位数称为字长。如果是 32 位 CPU。其字长为 32 位，也就是 4 个字节。一般来说字长越大，计算机处理信息的速度就越快。

因为对齐的是字节，所以也叫字节对齐。内存对齐时编译器或虚拟机的工作。不需要认为指定，但是作为开发者需要了解内存对齐的规则。

内存对齐包括基本数据对齐和结构体对齐。对于基本数据类型，默认对齐方式是按其大小进行对齐的，也被称作自然对齐。比如 Rust 中的 u32 占四个字节

假设对齐字节数位 N （1，2，4，8， 16），每个成员内存长度为 Len，Max(Len) 为最大成员内存长度。如果没有外部明确规定，N 默认按 Max(Len) 对齐。字节对齐规则为：
- 结构体的起始地址能够被 Max(Len) 整除。
- 结构体中每个成员相对于结构体起始地址的偏移量，即对齐值，应该是 Min(N, Len)。若不满足对齐值的要求，编译器会在成员之间填充若干字节。
- 结构体的总长度应该是Min(N, Max(Len)) 的倍数，若不满足总长度要求，则编译器会在为最后一个成员分配空间后填充若干字节。

### Rust 中资源管理

#### 变量和函数

变量分为全局变量和局部变量
全局变量分为常量和静态变量
常量：使用 const 关键字定义，并且需要指明类型，只能进行简单赋值。编译器会有效内连到每个使用到它的地方。
静态变量：使用 static 关键词定义，跟常量一样需要显式指明类型，只能进行简单赋值，每个静态变量都有一个全局的地址。静态变量和代码一起被存放在静态存储区中。
局部变量是指在函数中定义的变量

Rust 中资源管理主要通过所有权、生命周期、引用计数、智能指针、RC 和 Arc 等机制实现。

#### 智能指针与 RAII

Rust 中的指针大致可以分为三种：引用、原生指针（裸指针）和智能指针。
引用就是Rust提供的普通指针，用 `&` 和 `&mut` 来创建，形如： `&T` 和 `&mut T`。
原生指针是指形如： `*const T` 和 `*mut T` 这样的类型。

引用和原生指针的异同：
可以通过 as 操作符随意转换，例如 `&T` as `*const T`，`&mut T` as `*mut T`
原生指针可以再 unsafe 块下任意使用，不受 Rust 安全检查的影响。 而引用则必须受到编译器安全检查规则的限制。

智能指针：智能指针实际上是一种结构体，只不过它的行为类似指针。智能指针是对指针的一层封装，提供了一些额外的功能。比如自动释放内存。智能指针区别于常规结构体的特性在于它实现了 `Deref` 和 `Drop` 这两个 `trait`。`Deref` 提供了解引用能力，`Drop` 提供了自动析构能力。正是这两个 trait 使的智能指针拥有了类似指针的行为。类型决定行为，同时类型也取决于行为，不是指针胜似指针，所以称其为智能指针。开发者也可以编写自己的智能指针。

```rust
fn main() {
    let s = String::from("hello");
    // let deref_s: str = *s;
    let v = vec![1,2,3];
    // let deref_v = *v;
}
```

确定性析构：叫 RAII（Resource Acquisition Is Initialization），意思是资源获取及初始化。使用构造函数来初始化资源，使用析构函数来回收资源。 RAII 将资源托管给创建堆内存的指针对象本身来管理，并保证其资源在其生命周期内始终有效，一旦生命周期终止，资源会被马上回收。Rust 中的 Drop trait 就是析构函数。也叫作用域界定的资源管理（Scope-Bound Resource Management， SBRM）。这也是 Drop 的特性， 它允许在对象即将消亡之时，自行调用指定代码（drop 方法）。


Drop 被定义于 std::ops 模块中。

```rust
#[lang = "drop"]
pub trait Drop{
    fn drop(&mut self);
}
```

使用  Valgrind 来检测内存泄漏

```rust
fn create_box() {
    let box3 = Box::new(3);
}
fn main() {
    let box1 = Box::new(1);
    {
        let box2 = Box::new(2);
    }

    for _ in 1..100 {
        create_box();
    }
}

```

drop-flag 在函数调用栈中，为离开作用域的变量自动插入布尔标记。标注是否调用析构函数。这样在运行时就可以根据编译时做的标记来调用析构函数了。

对于结构体或者枚举的复合类型，并不存在隐式的 drop-flag，只有在函数调用时，这些复合结构实例被初始化之后，编译器才会加上 drop-flag。如果复合结构本身实现了 Drop， 则会调用它自己的析构函数，否则，会调用其成员的析构函数。

当变量被绑定给另外一个变量时，值发生移动时，也会被加上 drop-flag，在运行时会调用析构函数。加上 drop-flag 意味着生命周期结束后再也不能被访问。

对于实现了 Copy 的类型来说，是没有析构函数的。因为实现了 Copy 的类型会复制，其声明周期不受析构函数的影响，所以也就没有必要存在析构函数。


### 内存泄漏与内存安全

一个内存泄漏的例子

```rust
use std::{cell::RefCell, rc::Rc};

type NodePtr<T> = Option<Rc<RefCell<Node<T>>>>;

struct Node<T> {
    data: T,
    next: NodePtr<T>,
}
impl<T> Drop for Node<T>  {
    fn drop(&mut self) {
        println!("Dropping!");
    }
}
fn main() {
    let first = Rc::new(RefCell::new(Node {
        data: 1,
        next: None,
    }));
    let second = Rc::new(RefCell::new(Node {
        data: 2,
        next: Some(first.clone()),
    }));
    first.borrow_mut().next = Some(second.clone());
    second.borrow_mut().next = Some(first.clone());
}

```

内存安全

只要不出现以下行为即为内存安全

- 使用为定义内存：初始化的变量才能使用
- 空指针：不支持将整数转化未指针，使用 Option 避免空指针的使用
- 垂悬指针
- 缓存区溢出
- 非法释放未分配的指针或者已经释放过的指针

内存泄漏的原因
- 线程奔溃，析构函数无法调用
- 使用引用计数时造成了死循环
- 使用 Rust 标准库的 forget 主动泄漏

### 复合类型的内存分配和布局


